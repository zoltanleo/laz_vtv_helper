### USER

имеется :

- запись
  PMyRecord = ^TMyRecord;
  TMyRecord = record
    ID: SizeInt;          // ID узла дерева
    ParentID: SizeInt;    // содержит для child-узла ID root-узла (для root-узла равен -1)
    ActionName: String;   // ссылка-имя на Action в произвольном ActList
    Caption: String;      // заголовок узла
    tsName: String;       // имя вкладки PageControl
  end;

- динамический массив RecArr: TMyRecord

- тип TDictParentID = specialize TFPGMap<SizeInt, SizeInt> из модуля TFPGMap
1. Напиши процедуру одновременного заполнения массива RecArr примерно 50 записями и DictParentID: TDictParentID, где TKey - это индекс очередной записи в массиве RecArr, а TValue - ParentID этой записи
2. Напиши процедуру поиска первой записи по ParentID в RecArr
3. Напиши процедуру поиска первой записи по ParentID в DictParentID

Сравни их быстродействие. Также подробно комментируй код, начиная с секции var

### ASSISTANT

```pascal
program TreeSearchExample;

{$mode objfpc}{$M+}

uses
  SysUtils, Classes, FPHashMap, DateUtils;

type
  // Определение типа записи
  PMyRecord = ^TMyRecord;
  TMyRecord = record
    ID: SizeInt;          // ID узла дерева
    ParentID: SizeInt;    // содержит для child-узла ID root-узла (для root-узла равен -1)
    ActionName: String;   // ссылка-имя на Action в произвольном ActList
    Caption: String;      // заголовок узла
    tsName: String;       // имя вкладки PageControl
  end;

  // Тип словаря: TKey - индекс в массиве, TValue - ParentID
  TDictParentID = specialize TFPGMap<SizeInt, SizeInt>;

var
  // Динамический массив записей
  RecArr: array of TMyRecord;
  // Словарь для быстрого поиска: индекс -> ParentID
  DictParentID: TDictParentID;

// Процедура заполнения массива и словаря тестовыми данными
procedure FillTestData;
var
  i: Integer;
  CurrentParentID: SizeInt;
begin
  // Инициализируем генератор случайных чисел
  Randomize;

  // Устанавливаем размер массива (примерно 50 записей)
  SetLength(RecArr, 50);

  // Создаем экземпляр словаря
  DictParentID := TDictParentID.Create;

  // Заполняем массив и словарь
  for i := 0 to High(RecArr) do
  begin
    // Устанавливаем ID текущего узла
    RecArr[i].ID := i;

    // Для первого элемента (корень) устанавливаем ParentID = -1
    if i = 0 then
      CurrentParentID := -1
    else
      // Для остальных элементов выбираем случайный ParentID из уже существующих
      // (имитация древовидной структуры)
      CurrentParentID := Random(i); // ParentID будет от 0 до i-1

    // Присваиваем ParentID
    RecArr[i].ParentID := CurrentParentID;

    // Заполняем остальные поля
    RecArr[i].ActionName := 'Action' + IntToStr(i);
    RecArr[i].Caption := 'Caption' + IntToStr(i);
    RecArr[i].tsName := 'TabSheet' + IntToStr(i);

    // Добавляем в словарь: ключ - индекс, значение - ParentID
    DictParentID.Add(i, CurrentParentID);
  end;
end;

// Процедура поиска первой записи по ParentID в массиве RecArr
function FindFirstInArrayByParentID(ParentIDToFind: SizeInt): Integer;
var
  i: Integer;
begin
  Result := -1; // Возвращаем -1, если не найдено

  // Проходим по всем элементам массива
  for i := 0 to High(RecArr) do
  begin
    // Если нашли совпадение по ParentID
    if RecArr[i].ParentID = ParentIDToFind then
    begin
      Result := i; // Сохраняем индекс найденного элемента
      Break;       // Прерываем цикл, т.к. нам нужна только первая запись
    end;
  end;
end;

// Процедура поиска первой записи по ParentID в словаре DictParentID
function FindFirstInDictByParentID(ParentIDToFind: SizeInt): SizeInt;
var
  i: Integer;
  CurrentValue: SizeInt;
begin
  Result := -1; // Возвращаем -1, если не найдено

  // Проходим по всем парам ключ-значение в словаре
  for i := 0 to DictParentID.Count - 1 do
  begin
    // Получаем значение по индексу i
    CurrentValue := DictParentID.Data[i];

    // Если значение совпадает с искомым ParentID
    if CurrentValue = ParentIDToFind then
    begin
      // Возвращаем ключ (индекс в массиве), соответствующий этому значению
      Result := DictParentID.Keys[i];
      Break; // Прерываем цикл, т.к. нам нужна только первая запись
    end;
  end;
end;

// Процедура тестирования производительности
procedure TestPerformance;
var
  SearchParentID: SizeInt;
  StartTime, EndTime: Int64;
  FoundIndex: Integer;
  FoundKey: SizeInt;
  Iterations: Integer;
  i: Integer;

begin
  // Выбираем случайный ParentID для поиска
  if Length(RecArr) > 0 then
    SearchParentID := RecArr[Random(High(RecArr))].ParentID
  else
    SearchParentID := -999; // Если массив пустой

  WriteLn('Ищем ParentID: ', SearchParentID);
  WriteLn('');

  // === Тестирование поиска в массиве ===
  Iterations := 10000; // Количество итераций для более точного замера

  StartTime := GetTickCount64;
  for i := 1 to Iterations do
  begin
    FoundIndex := FindFirstInArrayByParentID(SearchParentID);
  end;
  EndTime := GetTickCount64;

  WriteLn('Поиск в массиве (', Iterations, ' итераций):');
  WriteLn('  Время выполнения: ', (EndTime - StartTime), ' мс');
  WriteLn('  Результат: индекс = ', FoundIndex);
  if (FoundIndex >= 0) and (FoundIndex <= High(RecArr)) then
    WriteLn('  Найденный ParentID: ', RecArr[FoundIndex].ParentID);
  WriteLn('');

  // === Тестирование поиска в словаре ===
  StartTime := GetTickCount64;
  for i := 1 to Iterations do
  begin
    FoundKey := FindFirstInDictByParentID(SearchParentID);
  end;
  EndTime := GetTickCount64;

  WriteLn('Поиск в словаре (', Iterations, ' итераций):');
  WriteLn('  Время выполнения: ', (EndTime - StartTime), ' мс');
  WriteLn('  Результат: индекс = ', FoundKey);
  if (FoundKey >= 0) and (FoundKey <= High(RecArr)) then
    WriteLn('  Найденный ParentID: ', RecArr[FoundKey].ParentID);
  WriteLn('');
end;

// Главная программа
begin
  try
    WriteLn('=== Заполнение тестовых данных ===');
    FillTestData;
    WriteLn('Заполнено ', Length(RecArr), ' записей.');
    WriteLn('');

    WriteLn('=== Тестирование производительности ===');
    TestPerformance;

    WriteLn('=== Сравнение алгоритмов ===');
    WriteLn('- Поиск в массиве: O(n) - линейный поиск по всем элементам.');
    WriteLn('- Поиск в словаре: O(n) - линейный поиск по парам ключ-значение.');
    WriteLn('  Оба метода имеют одинаковую теоретическую сложность O(n),');
    WriteLn('  но словарь может иметь накладные расходы на доступ к данным.');
    WriteLn('  Однако, при частом поиске по ключу (ID), словарь с индексами');
    WriteLn('  может быть полезен для других задач.');

  finally
    // Освобождаем ресурсы
    if Assigned(DictParentID) then
      DictParentID.Free;
  end;
end.
```