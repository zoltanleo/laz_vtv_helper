### USER

имеется :

- запись
  PMyRecord = ^TMyRecord;
  TMyRecord = record
    ID: SizeInt;          // ID узла дерева
    ParentID: SizeInt;    // содержит для child-узла ID root-узла (для root-узла равен -1)
    ActionName: String;   // ссылка-имя на Action в произвольном ActList
    Caption: String;      // заголовок узла
    tsName: String;       // имя вкладки PageControl
  end;

- два динамических массива RecArrScr: TMyRecord и RecArrDest: TMyRecord
1. Напиши процедуру заполнения массива RecArrScr примерно 20 записями, у некоторых из них должны быть одинаковыми ParentID
2. Напиши процедуру поиска и переноса по одной всех записей с неким ParentID из RecArrScr в RecArrDest
   Также подробно комментируй код, начиная с секции var

### ASSISTANT

```pascal
// Объявление типа записи
PMyRecord = ^TMyRecord;
TMyRecord = record
  ID: SizeInt;          // ID узла дерева
  ParentID: SizeInt;    // содержит для child-узла ID root-узла (для root-узла равен -1)
  ActionName: String;   // ссылка-имя на Action в произвольном ActList
  Caption: String;      // заголовок узла
  tsName: String;       // имя вкладки PageControl
end;

type
  TMyArray = array of TMyRecord;

// 1. Процедура заполнения массива RecArrScr примерно 20 записями
procedure FillRecArrScr(var RecArrScr: TMyArray);
var
  i: Integer;           // Счетчик цикла для итерации по элементам массива
begin
  // Устанавливаем размер массива в 20 элементов
  SetLength(RecArrScr, 20);

  // Заполняем массив тестовыми данными
  for i := 0 to High(RecArrScr) do
  begin
    // Присваиваем уникальный ID каждому элементу (от 1 до 20)
    RecArrScr[i].ID := i + 1;

    // Присваиваем ParentID, чтобы создать группировку:
    // - корневые элементы (ParentID = -1): элементы 0, 4, 8, 12, 15
    // - остальные будут дочерними к предыдущим корневым
    case i of
      0, 4, 8, 12, 15: RecArrScr[i].ParentID := -1; // Корневые элементы
      1..3: RecArrScr[i].ParentID := 1;             // Дочерние для элемента с ID=1
      5..7: RecArrScr[i].ParentID := 5;             // Дочерние для элемента с ID=5
      9..11: RecArrScr[i].ParentID := 9;            // Дочерние для элемента с ID=9
      13..14: RecArrScr[i].ParentID := 13;          // Дочерние для элемента с ID=13
      16..19: RecArrScr[i].ParentID := 17;          // Дочерние для элемента с ID=17
    else
      RecArrScr[i].ParentID := -1;
    end;

    // Присваиваем имя действия (ActionName) на основе ID
    RecArrScr[i].ActionName := 'Action' + IntToStr(RecArrScr[i].ID);

    // Присваиваем заголовок узла
    RecArrScr[i].Caption := 'Caption for ID ' + IntToStr(RecArrScr[i].ID);

    // Присваиваем имя вкладки PageControl
    RecArrScr[i].tsName := 'TabSheet' + IntToStr(RecArrScr[i].ID);
  end;
end;

// 2. Процедура поиска и переноса по одной всех записей с неким ParentID из RecArrScr в RecArrDest
procedure MoveRecordsByParentID(ParentIDToMove: SizeInt; 
                                var RecArrScr: TMyArray; 
                                var RecArrDest: TMyArray);
var
  i: Integer;           // Счетчик цикла для итерации по исходному массиву
  j: Integer;           // Вспомогательный счетчик для сдвига элементов
  FoundIndex: Integer;  // Индекс найденного элемента в исходном массиве
  NewDestLength: Integer; // Новая длина целевого массива после добавления элемента
  NewScrLength: Integer;  // Новая длина исходного массива после удаления элемента
begin
  // Ищем первый элемент в исходном массиве с заданным ParentID
  FoundIndex := -1;     // Инициализируем индекс как "не найдено"
  for i := 0 to High(RecArrScr) do
  begin
    if RecArrScr[i].ParentID = ParentIDToMove then
    begin
      FoundIndex := i;  // Сохраняем индекс первого найденного элемента
      Break;            // Прерываем цикл, так как нужно переместить только одну запись
    end;
  end;

  // Если элемент с указанным ParentID найден
  if FoundIndex <> -1 then
  begin
    // Увеличиваем размер целевого массива на 1
    NewDestLength := Length(RecArrDest) + 1;
    SetLength(RecArrDest, NewDestLength);

    // Копируем найденный элемент из исходного массива в конец целевого
    RecArrDest[High(RecArrDest)] := RecArrScr[FoundIndex];

    // Уменьшаем размер исходного массива на 1
    NewScrLength := Length(RecArrScr) - 1;

    // Сдвигаем все элементы после найденного на одну позицию влево
    // для "удаления" найденного элемента
    for j := FoundIndex to NewScrLength - 1 do
    begin
      RecArrScr[j] := RecArrScr[j + 1]; // Перемещаем следующий элемент на место текущего
    end;

    // Устанавливаем новую длину исходного массива
    SetLength(RecArrScr, NewScrLength);
  end;
  // Если элемент не найден, процедура завершается без изменений
end;
```